# Опасности случайного конструктора преобразования C ++

Рассмотрим этот класс:
```
class Buffer
{
public:
  Buffer(size_t capacity);
  Buffer(std::initializer_list<int> values);
};
```
Вы можете создать неинициализированный буфер определенной емкости или инициализированный буфер.

Однопараметрический конструктор также служит конструктором преобразования, что приводит к следующему:
```
Buffer buffer(24); // create a buffer of size 24
Buffer buffer({ 1, 3, 5 }); // create an initialized 3-byte buffer
```
Ладно, это не так уж плохо. Но вы также получите это:
```
Buffer buffer = 24; // um...
Buffer buffer = { 1, 3, 5 };
```
Они эквивалентны первым двум версиям, но вы должны признать, что версия = 24 выглядит действительно странно.

Вы также получите это:
```
extern void Send(Buffer const& b);
Send('c'); // um...
```
Это полностью компилируется, но не отправляет символ «c», как это выглядит. Вместо этого он создает неинициализированный буфер размером 0x63 = 99 и отправляет его.

Если это не то, что вы намеревались, тогда вам будет полезно использовать ключевое слово explicit, чтобы предотвратить использование конструктора в качестве конструкций преобразования.
```
class Buffer
{
public:
  explicit Buffer(size_t capacity);
  Buffer(std::initializer_list<int> values);
};
```
};
Я сделал первый конструктор явным, так как я не хочу, чтобы вы передавали целое число там, где ожидается буфер. Однако я оставил список инициализаторов как допустимый конструктор преобразования, потому что кажется разумным позволить кому-то написать
```
Send({ 1, 2, 3 });
```
Автор Raymond Chen
[Ссылка на оригинал статьи](https://devblogs.microsoft.com/oldnewthing/20210115-00/?p=104719)
