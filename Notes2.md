# Инициализирующий конструктор выглядит как присваивание, но это не так.
Некоторое время назад я предупреждал об опасностях случайного конструктора преобразования C ++: конструктор с одним параметром по умолчанию считается конструктором преобразования; вы можете отказаться от этого, явно отметив конструктор.

Я привел в качестве примера этот класс:
```
class Buffer
{
public:
  Buffer(size_t capacity);
  Buffer(std::initializer_list<int> values);
};
```
Конструктор size_t не помечен как явный, поэтому это конструктор преобразования. И это позволяет делать такие странные вещи:
```
Buffer b = 1; // um...
```
Что именно здесь происходит?

Распространенное заблуждение состоит в том, что происходит создание временного буфера (с емкостью 1), а затем этот временный буфер назначается целевому буферу b.

Это не то, что происходит. Вы можете доказать это, удалив операторы присваивания.
```
class Buffer
{
public:
  Buffer(size_t capacity);
  Buffer(std::initializer_list<int> values);
  Buffer& operator=(Buffer const&) = delete;
  Buffer& operator=(Buffer&&) = delete;
};

Buffer b = 1; // still compiles
```
(Удаление оператора присваивания перемещения излишне, поскольку объявление оператора присваивания копии автоматически подавляет неявный оператор присваивания перемещения. Но я удалил его явно для акцента.)

Несмотря на то, что в заявлении есть знак равенства, фактического присвоения нет.

Если задуматься, не может быть присваивания, потому что оператор присваивания предполагает, что это относится к уже построенному объекту. Но у нас еще нет построенного объекта.

Согласно языковым правилам,```Buffer b = 1; - это инициализация копирования, и инициализация копии выполняется путем взятия объекта с правой стороны и, если типы не совпадают, ¹ он ищет конструктор преобразования.```


Знак равенства здесь не означает присвоение. Это просто причуда синтаксиса.

¹ Если типы совпадают, то «выражение инициализатора используется для инициализации целевого объекта». На этом этапе вступает в действие copy elision:
```
extern Buffer get_buffer();

Buffer b = get_buffer();
```
Буфер, возвращаемый get_buffer (), помещается непосредственно в память, занимаемую b.

Копирование элизии также означает, что ``` Buffer b = Buffer(1); 
не создает временный буфер емкостью 1, а затем создает b из этого временного буфера. Вместо этого буфер емкости 1 строится непосредственно в b. Результат такой же, как у Buffer b (1) ;.```

Поскольку правило исключения копирования может повторяться,
```
Buffer b = Buffer(Buffer(Buffer(1)));
```
то же самое, что Buffer b (1) ;, потому что каждое повторение правила удаляет один из вызовов ```Buffer(...)```.
